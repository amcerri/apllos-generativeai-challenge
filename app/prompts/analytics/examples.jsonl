{"input": "Receita mensal em 2017 considerando order_items.price + order_items.freight_value e a data orders.order_purchase_timestamp.", "output": {"sql": "SELECT date_trunc('month', o.order_purchase_timestamp) AS period, SUM(oi.price + oi.freight_value) AS revenue FROM orders o JOIN order_items oi ON o.order_id = oi.order_id WHERE o.order_purchase_timestamp >= '2017-01-01' AND o.order_purchase_timestamp < '2018-01-01' GROUP BY period ORDER BY period", "params": {"year": 2017}, "reason": "monthly revenue for 2017 using orders timestamp and items price+freight", "limit_applied": false, "warnings": []}}
{"input": "Top 5 categorias por faturamento (R$).", "output": {"sql": "SELECT p.product_category_name AS category, SUM(oi.price + oi.freight_value) AS revenue FROM order_items oi JOIN products p ON oi.product_id = p.product_id GROUP BY category ORDER BY revenue DESC LIMIT 5", "params": {"top": 5}, "reason": "top-N categories by revenue", "limit_applied": false, "warnings": []}}
{"input": "Frete médio por estado do cliente.", "output": {"sql": "SELECT c.customer_state AS state, AVG(oi.freight_value) AS avg_freight FROM orders o JOIN customers c ON o.customer_id = c.customer_id JOIN order_items oi ON o.order_id = oi.order_id GROUP BY state ORDER BY state", "params": {}, "reason": "average freight by customer state", "limit_applied": false, "warnings": []}}
{"input": "Listar meus pedidos mais recentes (customer_id = 'CUST123').", "output": {"sql": "SELECT o.order_id, o.order_status, o.order_purchase_timestamp FROM orders o WHERE o.customer_id = 'CUST123' ORDER BY o.order_purchase_timestamp DESC LIMIT 200", "params": {"customer_id": "CUST123"}, "reason": "sample recent orders for a specific customer with cap", "limit_applied": true, "warnings": []}}
{"input": "Pedidos por dia em junho/2018.", "output": {"sql": "SELECT date_trunc('day', o.order_purchase_timestamp) AS period, COUNT(*) AS orders FROM orders o WHERE o.order_purchase_timestamp >= '2018-06-01' AND o.order_purchase_timestamp < '2018-07-01' GROUP BY period ORDER BY period", "params": {"from": "2018-06-01", "to": "2018-07-01"}, "reason": "daily order volume in June 2018", "limit_applied": false, "warnings": []}}
{"input": "Taxa de cancelamento geral.", "output": {"sql": "SELECT 100.0 * SUM(CASE WHEN o.order_status = 'canceled' THEN 1 ELSE 0 END) / NULLIF(COUNT(*), 0) AS cancel_rate FROM orders o", "params": {}, "reason": "cancellation rate over all orders", "limit_applied": false, "warnings": []}}
{"input": "Média de review por mês.", "output": {"sql": "SELECT date_trunc('month', o.order_purchase_timestamp) AS period, AVG(r.review_score) AS avg_score FROM orders o JOIN order_reviews r ON o.order_id = r.order_id GROUP BY period ORDER BY period", "params": {}, "reason": "monthly average review score", "limit_applied": false, "warnings": []}}
{"input": "Top 10 sellers por receita em 2017.", "output": {"sql": "SELECT oi.seller_id, SUM(oi.price + oi.freight_value) AS revenue FROM orders o JOIN order_items oi ON o.order_id = oi.order_id WHERE o.order_purchase_timestamp >= '2017-01-01' AND o.order_purchase_timestamp < '2018-01-01' GROUP BY oi.seller_id ORDER BY revenue DESC LIMIT 10", "params": {"year": 2017, "top": 10}, "reason": "top sellers by revenue for 2017", "limit_applied": false, "warnings": []}}
{"input": "Distribuição por tipo de pagamento.", "output": {"sql": "SELECT op.payment_type, COUNT(*) AS cnt, 100.0 * COUNT(*) / NULLIF(SUM(COUNT(*)) OVER (), 0) AS pct FROM order_payments op GROUP BY op.payment_type ORDER BY cnt DESC", "params": {}, "reason": "payment type distribution with count and share", "limit_applied": false, "warnings": []}}
{"input": "Margem bruta por categoria.", "output": {"sql": "SELECT p.product_category_name AS category, SUM(oi.price + oi.freight_value) AS revenue FROM order_items oi JOIN products p ON oi.product_id = p.product_id GROUP BY category ORDER BY revenue DESC", "params": {}, "reason": "approximate revenue by category; requested field not available", "limit_applied": false, "warnings": ["invalid_column:gross_margin"]}}
{"input": "Identifique produtos com alta demanda mas baixa satisfação do cliente (score de review).", "output": {"sql": "SELECT oi.product_id, COUNT(oi.order_id) AS demand, AVG(reviews.review_score) AS avg_review_score FROM order_items oi JOIN orders o ON oi.order_id = o.order_id LEFT JOIN order_reviews reviews ON o.order_id = reviews.order_id GROUP BY oi.product_id HAVING COUNT(oi.order_id) > 10 AND AVG(reviews.review_score) < 3 ORDER BY demand DESC", "params": {"min_demand": 10, "max_score": 3}, "reason": "products with high demand but low customer satisfaction", "limit_applied": false, "warnings": []}}
{"input": "Explique o que é o status 'delivered'.", "output": {"sql": "SELECT 1 AS noop LIMIT 1", "params": {}, "reason": "non analytical intent; safe minimal query", "limit_applied": true, "warnings": ["non_analytical_intent"]}}
{"input": "Contar itens por pedido na tabela orders_items.", "output": {"sql": "SELECT oi.order_id, COUNT(*) AS item_count FROM order_items oi GROUP BY oi.order_id ORDER BY item_count DESC", "params": {}, "reason": "item count per order using order_items table", "limit_applied": false, "warnings": ["invalid_table:orders_items"]}}
{"input": "Clientes distintos em 2017.", "output": {"sql": "SELECT COUNT(DISTINCT o.customer_id) AS distinct_customers FROM orders o WHERE o.order_purchase_timestamp >= '2017-01-01' AND o.order_purchase_timestamp < '2018-01-01'", "params": {"year": 2017}, "reason": "distinct customers for 2017", "limit_applied": false, "warnings": []}}
{"input": "Top 10 produtos por volume.", "output": {"sql": "SELECT oi.product_id, COUNT(*) AS items FROM order_items oi GROUP BY oi.product_id ORDER BY items DESC LIMIT 10", "params": {"top": 10}, "reason": "top products by item count", "limit_applied": false, "warnings": []}}
{"input": "Pedidos entregues por estado do vendedor.", "output": {"sql": "SELECT s.seller_state AS state, COUNT(*) AS delivered_orders FROM orders o JOIN order_items oi ON o.order_id = oi.order_id JOIN sellers s ON oi.seller_id = s.seller_id WHERE o.order_status = 'delivered' GROUP BY state ORDER BY delivered_orders DESC", "params": {}, "reason": "delivered orders grouped by seller state", "limit_applied": false, "warnings": []}}
{"input": "Quantos clientes fizeram mais de 3 pedidos?", "output": {"sql": "SELECT COUNT(*) AS customer_count FROM (SELECT customer_id FROM analytics.orders GROUP BY customer_id HAVING COUNT(*) > 3) subquery", "params": {"threshold": 3}, "reason": "count customers with more than 3 orders using subquery pattern", "limit_applied": false, "warnings": []}}
{"input": "Analise o comportamento de recompra: quantos clientes fizeram mais de 3 pedidos?", "output": {"sql": "SELECT COUNT(*) AS customer_count FROM (SELECT customer_id FROM analytics.orders GROUP BY customer_id HAVING COUNT(*) > 3) subquery", "params": {"threshold": 3}, "reason": "count customers with more than 3 orders for recompra analysis", "limit_applied": false, "warnings": []}}
{"input": "Qual é a receita média por pedido nos últimos 6 meses, segmentada por estado do cliente?", "output": {"sql": "SELECT c.customer_state, AVG(oi.price + oi.freight_value) AS average_revenue FROM analytics.orders o JOIN analytics.order_items oi ON o.order_id = oi.order_id JOIN analytics.customers c ON o.customer_id = c.customer_id WHERE o.order_purchase_timestamp >= CURRENT_DATE - INTERVAL '6 months' GROUP BY c.customer_state ORDER BY average_revenue DESC", "params": {"period": "6 months"}, "reason": "average revenue per order by customer state for last 6 months with temporal filter", "limit_applied": false, "warnings": []}}
{"input": "Qual é a distribuição de clientes por frequência de compra e como isso varia por estado?", "output": {"sql": "SELECT c.customer_state, COUNT(DISTINCT c.customer_id) AS customers, AVG(order_count) AS avg_frequency FROM analytics.customers c JOIN (SELECT customer_id, COUNT(*) AS order_count FROM analytics.orders GROUP BY customer_id) freq ON c.customer_id = freq.customer_id GROUP BY c.customer_state ORDER BY avg_frequency DESC", "params": {}, "reason": "customer distribution by purchase frequency per state using subquery for per-customer metrics", "limit_applied": false, "warnings": []}}
{"input": "Qual é o tempo médio entre aprovação do pagamento e entrega, por transportadora?", "output": {"sql": "SELECT s.seller_id, s.seller_city, s.seller_state, AVG(EXTRACT(EPOCH FROM (o.order_delivered_customer_date - o.order_approved_at)) / 3600) AS average_delivery_time_hours FROM analytics.orders o JOIN analytics.order_items oi ON o.order_id = oi.order_id JOIN analytics.sellers s ON oi.seller_id = s.seller_id WHERE o.order_delivered_customer_date IS NOT NULL AND o.order_approved_at IS NOT NULL GROUP BY s.seller_id, s.seller_city, s.seller_state ORDER BY average_delivery_time_hours", "params": {}, "reason": "average delivery time by seller (proxy for carrier) with location info", "limit_applied": false, "warnings": ["no_carrier_table:using_seller_as_proxy"]}}
{"input": "Analise a concentração de vendas: quantos vendedores representam 80% da receita?", "output": {"sql": "WITH seller_revenue AS (SELECT s.seller_id, SUM(oi.price + oi.freight_value) AS revenue FROM analytics.order_items oi JOIN analytics.sellers s ON oi.seller_id = s.seller_id GROUP BY s.seller_id), total_revenue AS (SELECT SUM(revenue) AS total FROM seller_revenue), cumulative AS (SELECT seller_id, revenue, SUM(revenue) OVER (ORDER BY revenue DESC) AS cumulative_revenue, (SELECT total FROM total_revenue) AS total_revenue FROM seller_revenue) SELECT COUNT(*) AS sellers_for_80_percent FROM cumulative WHERE cumulative_revenue <= 0.8 * total_revenue", "params": {"percentage": 80}, "reason": "calculate number of sellers representing 80% of revenue using window functions", "limit_applied": false, "warnings": []}}
{"input": "Receita nos últimos 3 meses por categoria", "output": {"sql": "SELECT p.product_category_name, SUM(oi.price + oi.freight_value) AS revenue FROM analytics.orders o JOIN analytics.order_items oi ON o.order_id = oi.order_id JOIN analytics.products p ON oi.product_id = p.product_id WHERE o.order_purchase_timestamp >= CURRENT_DATE - INTERVAL '3 months' GROUP BY p.product_category_name ORDER BY revenue DESC", "params": {"period": "3 months"}, "reason": "revenue by category for last 3 months with temporal filter", "limit_applied": false, "warnings": []}}
{"input": "Vendas do último ano segmentadas por trimestre", "output": {"sql": "SELECT date_trunc('quarter', o.order_purchase_timestamp) AS quarter, SUM(oi.price + oi.freight_value) AS revenue FROM analytics.orders o JOIN analytics.order_items oi ON o.order_id = oi.order_id WHERE o.order_purchase_timestamp >= CURRENT_DATE - INTERVAL '1 year' GROUP BY quarter ORDER BY quarter", "params": {"period": "1 year"}, "reason": "quarterly sales for last year with temporal filter", "limit_applied": false, "warnings": []}}
{"input": "Quantos clientes compraram apenas uma vez?", "output": {"sql": "SELECT COUNT(*) AS single_purchase_customers FROM (SELECT customer_id FROM analytics.orders GROUP BY customer_id HAVING COUNT(*) = 1) subquery", "params": {"threshold": 1}, "reason": "count customers with exactly one purchase using subquery", "limit_applied": false, "warnings": []}}
{"input": "Frequência média de compras por cliente em cada estado", "output": {"sql": "SELECT c.customer_state, COUNT(DISTINCT c.customer_id) AS customers, COUNT(o.order_id) AS total_orders, ROUND(COUNT(o.order_id)::numeric / NULLIF(COUNT(DISTINCT c.customer_id), 0), 2) AS avg_frequency FROM analytics.customers c LEFT JOIN analytics.orders o ON c.customer_id = o.customer_id GROUP BY c.customer_state ORDER BY avg_frequency DESC", "params": {}, "reason": "average purchase frequency per customer by state using proper aggregation", "limit_applied": false, "warnings": []}}
{"input": "Clientes com maior frequência de compra por estado", "output": {"sql": "WITH customer_frequency AS (SELECT c.customer_id, c.customer_state, COUNT(o.order_id) AS order_count FROM analytics.customers c LEFT JOIN analytics.orders o ON c.customer_id = o.customer_id GROUP BY c.customer_id, c.customer_state), state_max AS (SELECT customer_state, MAX(order_count) AS max_orders FROM customer_frequency GROUP BY customer_state) SELECT cf.customer_state, cf.customer_id, cf.order_count FROM customer_frequency cf JOIN state_max sm ON cf.customer_state = sm.customer_state AND cf.order_count = sm.max_orders ORDER BY cf.customer_state", "params": {}, "reason": "customers with highest purchase frequency per state using CTE", "limit_applied": false, "warnings": []}}
{"input": "Tempo médio de entrega por região do vendedor", "output": {"sql": "SELECT s.seller_state, AVG(EXTRACT(EPOCH FROM (o.order_delivered_customer_date - o.order_approved_at)) / 3600) AS avg_delivery_hours FROM analytics.orders o JOIN analytics.order_items oi ON o.order_id = oi.order_id JOIN analytics.sellers s ON oi.seller_id = s.seller_id WHERE o.order_delivered_customer_date IS NOT NULL AND o.order_approved_at IS NOT NULL GROUP BY s.seller_state ORDER BY avg_delivery_hours", "params": {}, "reason": "average delivery time by seller state (proxy for logistics regions)", "limit_applied": false, "warnings": []}}
{"input": "Análise de logística: tempo médio por transportadora", "output": {"sql": "SELECT s.seller_id, s.seller_city, s.seller_state, AVG(EXTRACT(EPOCH FROM (o.order_delivered_customer_date - o.order_approved_at)) / 3600) AS avg_delivery_hours FROM analytics.orders o JOIN analytics.order_items oi ON o.order_id = oi.order_id JOIN analytics.sellers s ON oi.seller_id = s.seller_id WHERE o.order_delivered_customer_date IS NOT NULL AND o.order_approved_at IS NOT NULL GROUP BY s.seller_id, s.seller_city, s.seller_state ORDER BY avg_delivery_hours", "params": {}, "reason": "delivery time analysis using seller as proxy for carrier", "limit_applied": false, "warnings": ["no_carrier_table:using_seller_as_proxy"]}}
{"input": "Produtos mais vendidos nos últimos 30 dias", "output": {"sql": "SELECT p.product_id, p.product_category_name, COUNT(oi.order_id) AS sales_count FROM analytics.orders o JOIN analytics.order_items oi ON o.order_id = oi.order_id JOIN analytics.products p ON oi.product_id = p.product_id WHERE o.order_purchase_timestamp >= CURRENT_DATE - INTERVAL '30 days' GROUP BY p.product_id, p.product_category_name ORDER BY sales_count DESC", "params": {"period": "30 days"}, "reason": "top products by sales count for last 30 days with temporal filter", "limit_applied": false, "warnings": []}}
{"input": "Receita média por pedido na última semana", "output": {"sql": "SELECT AVG(oi.price + oi.freight_value) AS avg_order_value FROM analytics.orders o JOIN analytics.order_items oi ON o.order_id = oi.order_id WHERE o.order_purchase_timestamp >= CURRENT_DATE - INTERVAL '7 days'", "params": {"period": "7 days"}, "reason": "average order value for last week with temporal filter", "limit_applied": false, "warnings": []}}
{"input": "Vendedores que representam 90% da receita", "output": {"sql": "WITH seller_revenue AS (SELECT s.seller_id, SUM(oi.price + oi.freight_value) AS revenue FROM analytics.order_items oi JOIN analytics.sellers s ON oi.seller_id = s.seller_id GROUP BY s.seller_id), total_revenue AS (SELECT SUM(revenue) AS total FROM seller_revenue), cumulative AS (SELECT seller_id, revenue, SUM(revenue) OVER (ORDER BY revenue DESC) AS cumulative_revenue, (SELECT total FROM total_revenue) AS total_revenue FROM seller_revenue) SELECT COUNT(*) AS sellers_for_90_percent FROM cumulative WHERE cumulative_revenue <= 0.9 * total_revenue", "params": {"percentage": 90}, "reason": "calculate sellers representing 90% of revenue using window functions", "limit_applied": false, "warnings": []}}
{"input": "Top 5 clientes por valor total gasto", "output": {"sql": "SELECT c.customer_id, c.customer_state, SUM(oi.price + oi.freight_value) AS total_spent FROM analytics.customers c JOIN analytics.orders o ON c.customer_id = o.customer_id JOIN analytics.order_items oi ON o.order_id = oi.order_id GROUP BY c.customer_id, c.customer_state ORDER BY total_spent DESC LIMIT 5", "params": {"top": 5}, "reason": "top 5 customers by total spending", "limit_applied": false, "warnings": []}}
{"input": "Correlação entre valor do pedido e score de avaliação", "output": {"sql": "SELECT AVG(oi.price + oi.freight_value) AS avg_order_value, AVG(r.review_score) AS avg_review_score, COUNT(*) AS orders FROM analytics.orders o JOIN analytics.order_items oi ON o.order_id = oi.order_id JOIN analytics.order_reviews r ON o.order_id = r.order_id", "params": {}, "reason": "correlation analysis between order value and review score", "limit_applied": false, "warnings": []}}
{"input": "Distribuição de pedidos por status nos últimos 2 meses", "output": {"sql": "SELECT o.order_status, COUNT(*) AS order_count, 100.0 * COUNT(*) / NULLIF(SUM(COUNT(*)) OVER (), 0) AS percentage FROM analytics.orders o WHERE o.order_purchase_timestamp >= CURRENT_DATE - INTERVAL '2 months' GROUP BY o.order_status ORDER BY order_count DESC", "params": {"period": "2 months"}, "reason": "order status distribution for last 2 months with temporal filter", "limit_applied": false, "warnings": []}}
{"input": "Sazonalidade de vendas por mês do ano", "output": {"sql": "SELECT EXTRACT(MONTH FROM o.order_purchase_timestamp) AS month, COUNT(*) AS orders, SUM(oi.price + oi.freight_value) AS revenue FROM analytics.orders o JOIN analytics.order_items oi ON o.order_id = oi.order_id GROUP BY EXTRACT(MONTH FROM o.order_purchase_timestamp) ORDER BY month", "params": {}, "reason": "seasonal analysis by month of year", "limit_applied": false, "warnings": []}}
{"input": "Produtos comprados juntos com maior frequência", "output": {"sql": "SELECT oi1.product_id AS product_1, oi2.product_id AS product_2, COUNT(*) AS co_purchase_count FROM analytics.order_items oi1 JOIN analytics.order_items oi2 ON oi1.order_id = oi2.order_id AND oi1.product_id < oi2.product_id GROUP BY oi1.product_id, oi2.product_id ORDER BY co_purchase_count DESC", "params": {}, "reason": "cross-selling analysis with product pairs ordered by frequency", "limit_applied": false, "warnings": []}}
{"input": "Taxa de conversão por método de pagamento", "output": {"sql": "SELECT op.payment_type, COUNT(DISTINCT o.order_id) AS orders, COUNT(DISTINCT CASE WHEN o.order_status LIKE '%delivered%' THEN o.order_id END) AS delivered, 100.0 * COUNT(DISTINCT CASE WHEN o.order_status LIKE '%delivered%' THEN o.order_id END) / NULLIF(COUNT(DISTINCT o.order_id), 0) AS conversion_rate FROM analytics.orders o JOIN analytics.order_payments op ON o.order_id = op.order_id GROUP BY op.payment_type ORDER BY conversion_rate DESC", "params": {}, "reason": "conversion rate analysis by payment method", "limit_applied": false, "warnings": []}}
{"input": "Churn rate por coorte mensal de primeira compra", "output": {"sql": "WITH first_purchase AS (SELECT customer_id, date_trunc('month', MIN(order_purchase_timestamp)) AS cohort_month FROM analytics.orders GROUP BY customer_id), recent_activity AS (SELECT customer_id, MAX(order_purchase_timestamp) AS last_order FROM analytics.orders GROUP BY customer_id) SELECT fp.cohort_month, COUNT(fp.customer_id) AS cohort_size, COUNT(CASE WHEN ra.last_order < CURRENT_DATE - INTERVAL '90 days' THEN fp.customer_id END) AS churned, 100.0 * COUNT(CASE WHEN ra.last_order < CURRENT_DATE - INTERVAL '90 days' THEN fp.customer_id END) / NULLIF(COUNT(fp.customer_id), 0) AS churn_rate FROM first_purchase fp JOIN recent_activity ra ON fp.customer_id = ra.customer_id GROUP BY fp.cohort_month ORDER BY fp.cohort_month", "params": {"churn_days": 90}, "reason": "churn rate by monthly cohort using 90-day inactivity threshold", "limit_applied": false, "warnings": []}}
{"input": "Eficiência logística por faixa de CEP", "output": {"sql": "SELECT s.seller_zip_code_prefix, COUNT(DISTINCT o.order_id) AS orders, AVG(oi.freight_value) AS avg_freight, AVG(EXTRACT(EPOCH FROM (o.order_delivered_customer_date - o.order_approved_at)) / 3600) AS avg_delivery_hours FROM analytics.orders o JOIN analytics.order_items oi ON o.order_id = oi.order_id JOIN analytics.sellers s ON oi.seller_id = s.seller_id WHERE o.order_delivered_customer_date IS NOT NULL AND o.order_approved_at IS NOT NULL GROUP BY s.seller_zip_code_prefix ORDER BY avg_freight, avg_delivery_hours", "params": {}, "reason": "logistics efficiency by zip code prefix with freight and delivery time", "limit_applied": false, "warnings": []}}
{"input": "Impacto do número de parcelas no valor do pedido", "output": {"sql": "SELECT op.payment_installments, COUNT(DISTINCT o.order_id) AS orders, AVG(op.payment_value) AS avg_payment_value, AVG(oi.price + oi.freight_value) AS avg_order_value FROM analytics.orders o JOIN analytics.order_payments op ON o.order_id = op.order_id JOIN analytics.order_items oi ON o.order_id = oi.order_id GROUP BY op.payment_installments ORDER BY op.payment_installments", "params": {}, "reason": "installment impact analysis on order value", "limit_applied": false, "warnings": []}}
{"input": "Análise de retenção: clientes que compraram novamente após 6 meses", "output": {"sql": "WITH first_orders AS (SELECT customer_id, MIN(order_purchase_timestamp) AS first_order_date FROM analytics.orders GROUP BY customer_id), subsequent_orders AS (SELECT o.customer_id, COUNT(*) AS repeat_orders FROM analytics.orders o JOIN first_orders fo ON o.customer_id = fo.customer_id WHERE o.order_purchase_timestamp > fo.first_order_date + INTERVAL '6 months' GROUP BY o.customer_id) SELECT COUNT(DISTINCT fo.customer_id) AS total_customers, COUNT(DISTINCT so.customer_id) AS retained_customers, 100.0 * COUNT(DISTINCT so.customer_id) / NULLIF(COUNT(DISTINCT fo.customer_id), 0) AS retention_rate FROM first_orders fo LEFT JOIN subsequent_orders so ON fo.customer_id = so.customer_id", "params": {"retention_period": "6 months"}, "reason": "customer retention analysis after 6 months", "limit_applied": false, "warnings": []}}
{"input": "Produtos com alta demanda mas baixa satisfação", "output": {"sql": "SELECT p.product_id, p.product_category_name, COUNT(oi.order_id) AS demand, AVG(r.review_score) AS avg_score FROM analytics.products p JOIN analytics.order_items oi ON p.product_id = oi.product_id LEFT JOIN analytics.order_reviews r ON oi.order_id = r.order_id GROUP BY p.product_id, p.product_category_name HAVING COUNT(oi.order_id) > 10 AND AVG(r.review_score) < 3 ORDER BY demand DESC", "params": {"min_demand": 10, "max_score": 3}, "reason": "products with high demand but low satisfaction using HAVING clause", "limit_applied": false, "warnings": []}}
{"input": "Penetração de categorias por estado", "output": {"sql": "SELECT p.product_category_name, c.customer_state, COUNT(DISTINCT o.order_id) AS orders, COUNT(DISTINCT c.customer_id) AS customers FROM analytics.products p JOIN analytics.order_items oi ON p.product_id = oi.product_id JOIN analytics.orders o ON oi.order_id = o.order_id JOIN analytics.customers c ON o.customer_id = c.customer_id GROUP BY p.product_category_name, c.customer_state ORDER BY p.product_category_name, orders DESC", "params": {}, "reason": "category penetration by state with order and customer counts", "limit_applied": false, "warnings": []}}
{"input": "Gargalos operacionais: pedidos com maior tempo de processamento", "output": {"sql": "SELECT o.order_id, o.order_status, o.order_purchase_timestamp, o.order_approved_at, o.order_delivered_customer_date, EXTRACT(EPOCH FROM (o.order_delivered_customer_date - o.order_approved_at)) / 3600 AS processing_hours FROM analytics.orders o WHERE o.order_delivered_customer_date IS NOT NULL AND o.order_approved_at IS NOT NULL ORDER BY processing_hours DESC LIMIT 10", "params": {"top": 10}, "reason": "operational bottlenecks analysis with processing time calculation", "limit_applied": false, "warnings": []}}
{"input": "Taxa de entrega no prazo por região", "output": {"sql": "SELECT c.customer_state, COUNT(*) AS total_orders, COUNT(CASE WHEN o.order_delivered_customer_date <= o.order_estimated_delivery_date THEN 1 END) AS on_time_deliveries, 100.0 * COUNT(CASE WHEN o.order_delivered_customer_date <= o.order_estimated_delivery_date THEN 1 END) / NULLIF(COUNT(*), 0) AS on_time_rate FROM analytics.orders o JOIN analytics.customers c ON o.customer_id = c.customer_id WHERE o.order_delivered_customer_date IS NOT NULL AND o.order_estimated_delivery_date IS NOT NULL GROUP BY c.customer_state ORDER BY on_time_rate DESC", "params": {}, "reason": "on-time delivery rate by customer region", "limit_applied": false, "warnings": []}}
{"input": "Crescimento trimestral de vendas por categoria", "output": {"sql": "SELECT date_trunc('quarter', o.order_purchase_timestamp) AS quarter, p.product_category_name, SUM(oi.price + oi.freight_value) AS revenue FROM analytics.orders o JOIN analytics.order_items oi ON o.order_id = oi.order_id JOIN analytics.products p ON oi.product_id = p.product_id GROUP BY quarter, p.product_category_name ORDER BY quarter, revenue DESC", "params": {}, "reason": "quarterly growth analysis by product category", "limit_applied": false, "warnings": []}}
{"input": "Clientes que fizeram pedidos nos últimos 15 dias", "output": {"sql": "SELECT DISTINCT c.customer_id, c.customer_state FROM analytics.customers c JOIN analytics.orders o ON c.customer_id = o.customer_id WHERE o.order_purchase_timestamp >= CURRENT_DATE - INTERVAL '15 days'", "params": {"period": "15 days"}, "reason": "recent customers with temporal filter", "limit_applied": false, "warnings": []}}
{"input": "Valor médio de frete por estado nos últimos 4 meses", "output": {"sql": "SELECT c.customer_state, AVG(oi.freight_value) AS avg_freight FROM analytics.orders o JOIN analytics.order_items oi ON o.order_id = oi.order_id JOIN analytics.customers c ON o.customer_id = c.customer_id WHERE o.order_purchase_timestamp >= CURRENT_DATE - INTERVAL '4 months' GROUP BY c.customer_state ORDER BY avg_freight DESC", "params": {"period": "4 months"}, "reason": "average freight by state for last 4 months with temporal filter", "limit_applied": false, "warnings": []}}
{"input": "Quantos pedidos foram cancelados na última quinzena?", "output": {"sql": "SELECT COUNT(*) AS canceled_orders FROM analytics.orders o WHERE o.order_status LIKE '%cancel%' AND o.order_purchase_timestamp >= CURRENT_DATE - INTERVAL '15 days'", "params": {"period": "15 days"}, "reason": "canceled orders count for last 15 days with temporal filter", "limit_applied": false, "warnings": []}}
{"input": "Distribua os clientes por número de pedidos feitos", "output": {"sql": "SELECT order_count, COUNT(*) AS customers FROM (SELECT customer_id, COUNT(*) AS order_count FROM analytics.orders GROUP BY customer_id) freq GROUP BY order_count ORDER BY order_count", "params": {}, "reason": "customer distribution by order frequency using subquery", "limit_applied": false, "warnings": []}}
{"input": "Frequência de compra média por cliente em SP", "output": {"sql": "SELECT AVG(order_count) AS avg_frequency FROM (SELECT c.customer_id, COUNT(o.order_id) AS order_count FROM analytics.customers c LEFT JOIN analytics.orders o ON c.customer_id = o.customer_id WHERE c.customer_state = 'SP' GROUP BY c.customer_id) freq", "params": {"state": "SP"}, "reason": "average purchase frequency for SP customers using subquery", "limit_applied": false, "warnings": []}}
{"input": "Como varia a frequência de compra entre os estados?", "output": {"sql": "SELECT c.customer_state, COUNT(DISTINCT c.customer_id) AS customers, COUNT(o.order_id) AS total_orders, ROUND(COUNT(o.order_id)::numeric / NULLIF(COUNT(DISTINCT c.customer_id), 0), 2) AS avg_frequency FROM analytics.customers c LEFT JOIN analytics.orders o ON c.customer_id = o.customer_id GROUP BY c.customer_state ORDER BY avg_frequency DESC", "params": {}, "reason": "purchase frequency variation by state using proper customer-level aggregation", "limit_applied": false, "warnings": []}}
{"input": "Tempo de entrega por empresa de transporte", "output": {"sql": "SELECT s.seller_id, s.seller_city, s.seller_state, COUNT(o.order_id) AS orders, AVG(EXTRACT(EPOCH FROM (o.order_delivered_customer_date - o.order_approved_at)) / 3600) AS avg_delivery_hours FROM analytics.orders o JOIN analytics.order_items oi ON o.order_id = oi.order_id JOIN analytics.sellers s ON oi.seller_id = s.seller_id WHERE o.order_delivered_customer_date IS NOT NULL AND o.order_approved_at IS NOT NULL GROUP BY s.seller_id, s.seller_city, s.seller_state ORDER BY avg_delivery_hours", "params": {}, "reason": "delivery time by carrier using seller as proxy with location details", "limit_applied": false, "warnings": ["no_carrier_table:using_seller_as_proxy"]}}
{"input": "Transportadoras mais eficientes por tempo de entrega", "output": {"sql": "SELECT s.seller_id, s.seller_state, AVG(EXTRACT(EPOCH FROM (o.order_delivered_customer_date - o.order_approved_at)) / 3600) AS avg_delivery_hours, COUNT(o.order_id) AS total_deliveries FROM analytics.orders o JOIN analytics.order_items oi ON o.order_id = oi.order_id JOIN analytics.sellers s ON oi.seller_id = s.seller_id WHERE o.order_delivered_customer_date IS NOT NULL AND o.order_approved_at IS NOT NULL GROUP BY s.seller_id, s.seller_state ORDER BY avg_delivery_hours LIMIT 10", "params": {"top": 10}, "reason": "most efficient carriers by delivery time using seller as proxy", "limit_applied": false, "warnings": ["no_carrier_table:using_seller_as_proxy"]}}
{"input": "Qual transportadora tem menor tempo médio de entrega?", "output": {"sql": "SELECT s.seller_id, s.seller_city, s.seller_state, AVG(EXTRACT(EPOCH FROM (o.order_delivered_customer_date - o.order_approved_at)) / 3600) AS avg_delivery_hours FROM analytics.orders o JOIN analytics.order_items oi ON o.order_id = oi.order_id JOIN analytics.sellers s ON oi.seller_id = s.seller_id WHERE o.order_delivered_customer_date IS NOT NULL AND o.order_approved_at IS NOT NULL GROUP BY s.seller_id, s.seller_city, s.seller_state ORDER BY avg_delivery_hours LIMIT 1", "params": {"top": 1}, "reason": "fastest carrier by delivery time using seller as proxy", "limit_applied": false, "warnings": ["no_carrier_table:using_seller_as_proxy"]}}
{"input": "Concentração de vendas: top 3 vendedores representam quantos % da receita?", "output": {"sql": "WITH seller_revenue AS (SELECT s.seller_id, SUM(oi.price + oi.freight_value) AS revenue FROM analytics.order_items oi JOIN analytics.sellers s ON oi.seller_id = s.seller_id GROUP BY s.seller_id ORDER BY revenue DESC), total_revenue AS (SELECT SUM(revenue) AS total FROM seller_revenue), top_sellers AS (SELECT revenue FROM seller_revenue LIMIT 3) SELECT 100.0 * SUM(ts.revenue) / tr.total AS top3_percentage FROM top_sellers ts, total_revenue tr", "params": {"top": 3}, "reason": "percentage of revenue from top 3 sellers using CTE", "limit_applied": false, "warnings": []}}
{"input": "Quantos vendedores fazem 50% da receita total?", "output": {"sql": "WITH seller_revenue AS (SELECT s.seller_id, SUM(oi.price + oi.freight_value) AS revenue FROM analytics.order_items oi JOIN analytics.sellers s ON oi.seller_id = s.seller_id GROUP BY s.seller_id), total_revenue AS (SELECT SUM(revenue) AS total FROM seller_revenue), cumulative AS (SELECT seller_id, revenue, SUM(revenue) OVER (ORDER BY revenue DESC) AS cumulative_revenue, (SELECT total FROM total_revenue) AS total_revenue FROM seller_revenue) SELECT COUNT(*) AS sellers_for_50_percent FROM cumulative WHERE cumulative_revenue <= 0.5 * total_revenue", "params": {"percentage": 50}, "reason": "sellers representing 50% of revenue using window functions", "limit_applied": false, "warnings": []}}
{"input": "Análise de concentração: 70% da receita vem de quantos vendedores?", "output": {"sql": "WITH seller_revenue AS (SELECT s.seller_id, SUM(oi.price + oi.freight_value) AS revenue FROM analytics.order_items oi JOIN analytics.sellers s ON oi.seller_id = s.seller_id GROUP BY s.seller_id), total_revenue AS (SELECT SUM(revenue) AS total FROM seller_revenue), cumulative AS (SELECT seller_id, revenue, SUM(revenue) OVER (ORDER BY revenue DESC) AS cumulative_revenue, (SELECT total FROM total_revenue) AS total_revenue FROM seller_revenue) SELECT COUNT(*) AS sellers_for_70_percent FROM cumulative WHERE cumulative_revenue <= 0.7 * total_revenue", "params": {"percentage": 70}, "reason": "sellers representing 70% of revenue using window functions", "limit_applied": false, "warnings": []}}
{"input": "Perfil de compra: clientes por faixa de valor gasto", "output": {"sql": "WITH customer_spending AS (SELECT c.customer_id, c.customer_state, SUM(oi.price + oi.freight_value) AS total_spent FROM analytics.customers c JOIN analytics.orders o ON c.customer_id = o.customer_id JOIN analytics.order_items oi ON o.order_id = oi.order_id GROUP BY c.customer_id, c.customer_state), spending_ranges AS (SELECT customer_id, customer_state, total_spent, CASE WHEN total_spent < 100 THEN 'Baixo (< R$ 100)' WHEN total_spent < 500 THEN 'Médio (R$ 100-500)' ELSE 'Alto (> R$ 500)' END AS spending_range FROM customer_spending) SELECT spending_range, COUNT(*) AS customers FROM spending_ranges GROUP BY spending_range ORDER BY MIN(total_spent)", "params": {}, "reason": "customer segmentation by spending ranges using CTE", "limit_applied": false, "warnings": []}}
{"input": "Clientes mais valiosos por estado", "output": {"sql": "WITH customer_value AS (SELECT c.customer_id, c.customer_state, SUM(oi.price + oi.freight_value) AS total_value FROM analytics.customers c JOIN analytics.orders o ON c.customer_id = o.customer_id JOIN analytics.order_items oi ON o.order_id = oi.order_id GROUP BY c.customer_id, c.customer_state), state_ranking AS (SELECT customer_id, customer_state, total_value, ROW_NUMBER() OVER (PARTITION BY customer_state ORDER BY total_value DESC) AS rank FROM customer_value) SELECT customer_state, customer_id, total_value FROM state_ranking WHERE rank = 1 ORDER BY total_value DESC", "params": {}, "reason": "most valuable customer per state using window functions", "limit_applied": false, "warnings": []}}
{"input": "Elasticidade de preço: como o valor afeta a demanda?", "output": {"sql": "WITH price_ranges AS (SELECT oi.product_id, oi.price, COUNT(*) AS demand, CASE WHEN oi.price < 50 THEN 'Baixo (< R$ 50)' WHEN oi.price < 200 THEN 'Médio (R$ 50-200)' ELSE 'Alto (> R$ 200)' END AS price_range FROM analytics.order_items oi GROUP BY oi.product_id, oi.price) SELECT price_range, AVG(demand) AS avg_demand, COUNT(DISTINCT product_id) AS products FROM price_ranges GROUP BY price_range ORDER BY AVG(demand) DESC", "params": {}, "reason": "price elasticity analysis using demand by price ranges", "limit_applied": false, "warnings": []}}
{"input": "Comportamento sazonal: vendas por dia da semana", "output": {"sql": "SELECT EXTRACT(DOW FROM o.order_purchase_timestamp) AS day_of_week, CASE EXTRACT(DOW FROM o.order_purchase_timestamp) WHEN 0 THEN 'Domingo' WHEN 1 THEN 'Segunda' WHEN 2 THEN 'Terça' WHEN 3 THEN 'Quarta' WHEN 4 THEN 'Quinta' WHEN 5 THEN 'Sexta' WHEN 6 THEN 'Sábado' END AS day_name, COUNT(*) AS orders, SUM(oi.price + oi.freight_value) AS revenue FROM analytics.orders o JOIN analytics.order_items oi ON o.order_id = oi.order_id GROUP BY EXTRACT(DOW FROM o.order_purchase_timestamp) ORDER BY day_of_week", "params": {}, "reason": "weekly seasonality analysis with day names", "limit_applied": false, "warnings": []}}
{"input": "Padrão horário: vendas por hora do dia", "output": {"sql": "SELECT EXTRACT(HOUR FROM o.order_purchase_timestamp) AS hour, COUNT(*) AS orders, SUM(oi.price + oi.freight_value) AS revenue FROM analytics.orders o JOIN analytics.order_items oi ON o.order_id = oi.order_id GROUP BY EXTRACT(HOUR FROM o.order_purchase_timestamp) ORDER BY hour", "params": {}, "reason": "hourly sales pattern analysis", "limit_applied": false, "warnings": []}}
{"input": "Retenção de clientes: quantos voltaram a comprar?", "output": {"sql": "WITH customer_orders AS (SELECT customer_id, COUNT(*) AS order_count FROM analytics.orders GROUP BY customer_id) SELECT CASE WHEN order_count = 1 THEN 'Único pedido' WHEN order_count <= 3 THEN '2-3 pedidos' WHEN order_count <= 5 THEN '4-5 pedidos' ELSE 'Mais de 5 pedidos' END AS retention_segment, COUNT(*) AS customers FROM customer_orders GROUP BY CASE WHEN order_count = 1 THEN 'Único pedido' WHEN order_count <= 3 THEN '2-3 pedidos' WHEN order_count <= 5 THEN '4-5 pedidos' ELSE 'Mais de 5 pedidos' END ORDER BY MIN(order_count)", "params": {}, "reason": "customer retention analysis by order frequency segments", "limit_applied": false, "warnings": []}}
{"input": "Quais categorias têm maior crescimento trimestral de vendas?", "output": {"sql": "WITH quarterly_sales AS (SELECT date_trunc('quarter', o.order_purchase_timestamp) AS quarter, p.product_category_name, SUM(oi.price + oi.freight_value) AS revenue FROM analytics.orders o JOIN analytics.order_items oi ON o.order_id = oi.order_id JOIN analytics.products p ON oi.product_id = p.product_id GROUP BY quarter, p.product_category_name), growth_calc AS (SELECT product_category_name, quarter, revenue, LAG(revenue) OVER (PARTITION BY product_category_name ORDER BY quarter) AS prev_revenue FROM quarterly_sales) SELECT product_category_name, quarter, revenue, prev_revenue, (revenue - COALESCE(prev_revenue, 0)) AS growth FROM growth_calc WHERE prev_revenue IS NOT NULL AND revenue > COALESCE(prev_revenue, 0) ORDER BY (revenue - COALESCE(prev_revenue, 0)) DESC", "params": {}, "reason": "quarterly growth analysis by product category using window functions to avoid WHERE with alias", "limit_applied": false, "warnings": []}}
{"input": "Penetração de categorias por estado brasileiro", "output": {"sql": "SELECT p.product_category_name, c.customer_state, COUNT(DISTINCT o.order_id) AS order_count, COUNT(DISTINCT c.customer_id) AS customer_count FROM analytics.products p JOIN analytics.order_items oi ON p.product_id = oi.product_id JOIN analytics.orders o ON oi.order_id = o.order_id JOIN analytics.customers c ON o.customer_id = c.customer_id GROUP BY p.product_category_name, c.customer_state ORDER BY p.product_category_name, order_count DESC", "params": {}, "reason": "category penetration by state with valid alias names without dots", "limit_applied": false, "warnings": []}}
{"input": "Crescimento de vendas por categoria nos últimos trimestres", "output": {"sql": "WITH quarterly_data AS (SELECT date_trunc('quarter', o.order_purchase_timestamp) AS quarter, p.product_category_name, SUM(oi.price + oi.freight_value) AS revenue FROM analytics.orders o JOIN analytics.order_items oi ON o.order_id = oi.order_id JOIN analytics.products p ON oi.product_id = p.product_id GROUP BY quarter, p.product_category_name), growth_analysis AS (SELECT product_category_name, quarter, revenue, LAG(revenue) OVER (PARTITION BY product_category_name ORDER BY quarter) AS previous_quarter_revenue FROM quarterly_data) SELECT product_category_name, quarter, revenue, previous_quarter_revenue, CASE WHEN previous_quarter_revenue IS NOT NULL THEN revenue - previous_quarter_revenue ELSE 0 END AS growth FROM growth_analysis ORDER BY quarter DESC, growth DESC", "params": {}, "reason": "quarterly growth with proper CTE structure avoiding WHERE clause on calculated fields", "limit_applied": false, "warnings": []}}
{"input": "Calcule o churn rate mensal dos clientes", "output": {"sql": "WITH first_purchase AS (SELECT o.customer_id, date_trunc(\"month\", o.order_purchase_timestamp) AS cohort_month FROM analytics.orders o GROUP BY o.customer_id, cohort_month), churned_customers AS (SELECT fp.customer_id, fp.cohort_month, COUNT(DISTINCT o.order_id) AS order_count FROM first_purchase fp LEFT JOIN analytics.orders o ON fp.customer_id = o.customer_id AND date_trunc(\"month\", o.order_purchase_timestamp) > fp.cohort_month GROUP BY fp.customer_id, fp.cohort_month HAVING COUNT(DISTINCT o.order_id) = 0) SELECT cc.cohort_month, COUNT(DISTINCT cc.customer_id) AS churned_count FROM churned_customers cc GROUP BY cc.cohort_month ORDER BY cc.cohort_month", "params": {}, "reason": "monthly churn rate calculation with proper column qualification", "limit_applied": false, "warnings": []}}
{"input": "Quais categorias de produtos têm maior crescimento de vendas trimestre a trimestre?", "output": {"sql": "WITH quarterly_sales AS (SELECT p.product_category_name AS category, date_trunc('quarter', o.order_purchase_timestamp) AS quarter, SUM(oi.price + oi.freight_value) AS total_revenue FROM analytics.orders o JOIN analytics.order_items oi ON o.order_id = oi.order_id JOIN analytics.products p ON oi.product_id = p.product_id GROUP BY category, quarter), growth_calc AS (SELECT category, quarter, total_revenue, LAG(total_revenue) OVER (PARTITION BY category ORDER BY quarter) AS previous_quarter_revenue FROM quarterly_sales) SELECT category, quarter, total_revenue, previous_quarter_revenue, (total_revenue - COALESCE(previous_quarter_revenue, 0)) AS growth FROM growth_calc WHERE previous_quarter_revenue IS NOT NULL ORDER BY (total_revenue - COALESCE(previous_quarter_revenue, 0)) DESC", "params": {}, "reason": "quarterly growth analysis by product category using CTE to avoid WHERE with alias", "limit_applied": false, "warnings": []}}
